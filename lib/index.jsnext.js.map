{"version":3,"file":"index.jsnext.js","sources":["../src/util.js","../src/base.js","../src/simple.js","../src/combined.js","../src/index.js"],"sourcesContent":["//\n//  util.js\n//  validated-attributes\n//\n//  Created by Patrick Schneider on 17.07.18.\n//  Copyright (c) 2018 MeetNow! GmbH. All rights reserved.\n//\n// @flow\n//\n\nconst typeConversion = {\n  undefined: 'undefined',\n  number: 'number',\n  boolean: 'boolean',\n  string: 'string',\n  function: 'function',\n  '[object Function]': 'function',\n  '[object RegExp]': 'regexp',\n  '[object Array]': 'array',\n  '[object Date]': 'date',\n  '[object Error]': 'error',\n  '[object Null]': 'null',\n  '[object Symbol]': 'symbol',\n};\n\nconst objToString = Object.prototype.toString;\n\nconst objHasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function typeofPlus(x: mixed): string {\n  return typeConversion[typeof x] || typeConversion[objToString.call(x)] || (x ? 'object' : 'null');\n}\n\nexport function hasOwnProperty(obj: Object, name: string): boolean {\n  return objHasOwnProperty.call(obj, name);\n}\n\n/**\n Variant of Object.assign to be consistent across implementations\n */\nexport function assign(obj: Object, source: ?Object): Object {\n  if (source != null) {\n    for (const key in source) {\n      if (hasOwnProperty(source, key)) {\n        obj[key] = source[key]; // eslint-disable-line no-param-reassign\n      }\n    }\n  }\n  return obj;\n}\n\n/**\n Variant of Object.keys to be consistent across implementations\n */\nexport function keys(obj: Object): Array<string> {\n  if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {\n    throw new TypeError('Object.keys called on non-object');\n  }\n  const result = [];\n  for (const key in obj) {\n    if (hasOwnProperty(obj, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n A variant of the NodeJS' inspect function for internal use\n */\nexport function inspect(value: any, depth: number = 3) {\n  let isArray;\n  switch (typeofPlus(value)) {\n    case 'undefined':\n      return 'undefined';\n    case 'number':\n      return value.toString();\n    case 'boolean':\n      return (value ? 'true' : 'false');\n    case 'string':\n      return `'${JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"')}'`;\n    case 'function':\n      return (value.name ? `[Function: ${value.name}]` : '[Function]');\n    case 'regexp':\n      return RegExp.prototype.toString.call(value);\n    case 'array':\n      isArray = true;\n      break;\n    case 'date':\n      return Date.prototype.toString.call(value);\n    case 'error':\n      return `[${Error.prototype.toString.call(value)}]`;\n    case 'null':\n      return 'null';\n    case 'symbol':\n      return Symbol.prototype.toString.call(value);\n    default:\n      isArray = false;\n      break;\n  }\n\n  if (depth === -1) {\n    if (isArray) {\n      return '[Array]';\n    }\n    else {\n      return '[Object]';\n    }\n  }\n\n  const contents = [];\n  if (isArray) {\n    for (let i = 0, l = value.length; i < l; ++i) {\n      contents.push(inspect(value[i], depth - 1));\n    }\n    return `[ ${contents.join(', ')} ]`;\n  }\n  else {\n    keys(value).forEach((key) => {\n      let name = JSON.stringify(key);\n      if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n        name = name.substr(1, name.length - 2);\n      }\n      else {\n        name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n      }\n      contents.push(`${name}: ${inspect(value[key], depth - 1)}`);\n    });\n    return `{ ${contents.join(', ')} }`;\n  }\n}\n","//\n//  base.js\n//  validated-attributes\n//\n//  Created by Patrick Schneider on 17.07.18.\n//  Copyright (c) 2018 MeetNow! GmbH. All rights reserved.\n//\n// @flow\n//\n\nimport type { ValidatorFn, DefaultValue } from './types';\n\nimport { assign, inspect } from './util';\n\n/**\n Error class for validation errors\n\n You might want to test a thrown error with `instanceof` against this class.\n */\nexport class AttributeValidationError extends Error {\n  expected: string;\n  got: mixed;\n  optional: boolean;\n\n  constructor(expected: string, got: mixed, optional: boolean) {\n    super(`expected: ${expected}${optional ? ' (optional)' : ''}\\ngot: ${inspect(got)}`);\n    this.expected = expected;\n    this.got = got;\n    this.optional = optional;\n  }\n}\n\n/**\n Base class for attributes\n\n You can inherit from this class to extend Attribute.js; you must override at\n least the `_clone` method.\n */\nexport class Attribute {\n  /** Name of the attribute; usually reflects its type */\n  name: string;\n\n  /** Arbitrary flags you can use for your application purposes */\n  flags: {[string]: mixed};\n\n  /** Default value of the attribute (function that creates a default or immutable value) */\n  default: DefaultValue;\n\n  /** Whether this attribute is marked as optional; changes behavior of validate and newSkeleton */\n  isOptional: bool;\n\n  /** Base validator function */\n  _validator: ValidatorFn;\n\n  /**\n   Base constructor for attribute objects\n\n   Takes a validator function and a default value\n   */\n  constructor(validator: ValidatorFn, defaultsTo: ?DefaultValue) {\n    this.flags = {};\n    this.default = defaultsTo;\n    this.isOptional = false;\n    this._validator = validator;\n  }\n\n  /**\n   Main method for validation\n\n   Throws `AttributeValidationError` on, you guessed it, validation errors.\n   Returns the validated object on success.\n\n   The default implementation calls the underlying validator function\n\n   Note: for use with flow type, cast the returned object to your target type.\n   */\n  validate(input: mixed): any {\n    if (input == null) {\n      if (!this.isOptional) {\n        throw new AttributeValidationError(this.name, input, false);\n      }\n    }\n    else if (!this._validator(input)) {\n      throw new AttributeValidationError(this.name, input, this.isOptional);\n    }\n    return input;\n  }\n\n  /**\n   Creates a new default value for this attribute\n\n   Returns the value set with `defaultsTo` or, if it is a function, invokes\n   it and returns its result.\n   */\n  newDefault(): mixed {\n    if (typeof this.default === 'function') {\n      return this.default();\n    }\n    else {\n      return this.default;\n    }\n  }\n\n  /**\n   Merges the given value with the default of this attribute\n\n   Optionally treats `null` as `undefined` even for optional attributes.\n\n   Works best for schema or tuple attributes since it works recursively; it will\n   also remove any fields that are not specified in the schema (!)\n   */\n  mergeDefault(value: mixed, nullIsUndefined: ?boolean): any {\n    if (value === undefined || (value === null && (!this.isOptional || nullIsUndefined))) {\n      return this.newDefault();\n    }\n    else {\n      return value;\n    }\n  }\n\n  /**\n   Returns a new skeleton for this attribute\n\n   This is most useful for schema or compound attributes, where it will emit\n   an object or array whose fields are set to null or which is empty.\n   */\n  newSkeleton(): mixed {\n    return null;\n  }\n\n  /**\n   Sets the attributes default value\n\n   The default can be a (immutable) value or a function creating a value. The\n   latter is recommended if the value is something mutable, like an array or\n   object.\n\n   Clones the attribute object.\n   */\n  defaultsTo(newDefault: DefaultValue): this {\n    const c = this._clone();\n    c.default = newDefault;\n    return c;\n  }\n\n  /**\n   Adds one or more boolean flags\n\n   Same as calling `with({'flag1': true, 'flag2': true, ...})`.\n\n   Clones the attribute object.\n   */\n  as(...flags: Array<string>): this {\n    const c = this._clone();\n    for (const flag of flags) {\n      if (typeof flag !== 'string') {\n        throw new Error('flags must be strings');\n      }\n      c.flags[flag] = true;\n    }\n    return c;\n  }\n\n  /**\n   Adds one or more arbitrary flags\n\n   Clones the attribute object.\n   */\n  with(flags: {[string]: mixed}): this {\n    const c = this._clone();\n    assign(c.flags, flags);\n    return c;\n  }\n\n  /**\n   Turns the attribute optional\n\n   Clones the attribute object.\n   */\n  makeOptional(): this {\n    const c = this._clone();\n    c.isOptional = true;\n    return c;\n  }\n\n  /**\n   Internal method to clone an attribute object\n\n   Subclasses must override this method, and call `_copyAttrProps` on the new\n   instance. Do not call the base implementation.\n   */\n  _clone(): Attribute {\n    return new Attribute(this._validator)._copyAttrProps(this);\n  }\n\n  /**\n   Internal method that copies internal properties from the given attribute to\n   this attribute\n\n   Used by `_clone`. Subclasses must call the base implementation before copying\n   their own properties.\n\n   The base implementation copies the name, isOptional, default and flags\n   (as shallow copy). Returns `this`.\n   */\n  _copyAttrProps(source: Attribute): this {\n    this.name = source.name;\n    this.isOptional = source.isOptional;\n    this.default = source.default;\n    assign(this.flags, source.flags);\n    return this;\n  }\n}\n","//\n//  simple.js\n//  validated-attributes\n//\n//  Created by Patrick Schneider on 17.07.18.\n//  Copyright (c) 2018 MeetNow! GmbH. All rights reserved.\n//\n// @flow\n//\n\nimport { Attribute } from './base';\n\nimport { typeofPlus } from './util';\n\nexport class FixedAttribute extends Attribute {\n  /** The fixed value itself */\n  value: mixed;\n\n  /** Type of the fixed value */\n  valueType: string;\n\n  constructor(value: mixed) {\n    super(x => x === value, value);\n    this.value = value;\n    this.valueType = typeofPlus(value);\n  }\n\n  _clone(): FixedAttribute {\n    return new FixedAttribute(this.value)._copyAttrProps(this);\n  }\n}\n\n/**\n Represents an instanceOf-attribute\n\n The class is instantiated with an emty constructor as default.\n */\nexport class ObjectAttribute extends Attribute {\n  cls: any;\n\n  constructor(Cls: any) {\n    super(x => x instanceof Cls, () => new Cls());\n    this.cls = Cls;\n  }\n\n  _clone(): ObjectAttribute {\n    return new ObjectAttribute(this.cls)._copyAttrProps(this);\n  }\n}\n","//\n//  combined.js\n//  validated-attributes\n//\n//  Created by Patrick Schneider on 17.07.18.\n//  Copyright (c) 2018 MeetNow! GmbH. All rights reserved.\n//\n// @flow\n//\n\nimport { AttributeValidationError, Attribute } from './base';\n\nimport { FixedAttribute } from './simple';\n\nimport type { ValidatorFn, ElementIterator } from './types';\n\nimport { typeofPlus, hasOwnProperty } from './util';\n\n/**\n Represents an oneOf-attribute\n\n The first value is used to generate the default.\n */\nexport class EnumAttribute extends Attribute {\n  /** List of valid attributes for this enum */\n  values: Array<Attribute>;\n\n  constructor(values: Array<any>) {\n    const attrs = values.map(toAttribute);\n    super(x => attrs.some(y => isValid(y, x)), attrs[0].default);\n    this.values = attrs;\n  }\n\n  _clone(): EnumAttribute {\n    return new EnumAttribute(this.values)._copyAttrProps(this);\n  }\n}\n\n/**\n Represents an array attribute with fixed number and type of entries\n\n The default value is an array with default values of each type. The skeleton\n is either `null` for optional tuples or an array with all values set to the\n skeleton of each type.\n */\nexport class TupleAttribute extends Attribute {\n  /** Array of attributes to validate the tuple's contents against */\n  elements: Array<Attribute>;\n\n  constructor(selements: Array<any>) {\n    if (typeofPlus(selements) !== 'array') {\n      throw new Error('you need to pass a plain array describing the elements');\n    }\n\n    const elements = [];\n    for (let i = 0; i < selements.length; i++) {\n      elements.push(toAttribute(selements[i]));\n    }\n\n    super(x => typeofPlus(x) === 'array', () => elements.map(e => e.newDefault()));\n    this.elements = elements;\n  }\n\n  validate(input: any): any {\n    super.validate(input);\n\n    if (input == null) {\n      return input;\n    }\n\n    if (input.length !== this.elements.length) {\n      throw new AttributeValidationError(\n        `tuple of length ${this.elements.length}`,\n        `tuple of length ${input.length}`,\n        this.isOptional\n      );\n    }\n\n    const errors = [];\n    for (let i = 0; i < this.elements.length; i++) {\n      try {\n        this.elements[i].validate(input[i]);\n      }\n      catch (err) {\n        if (err instanceof AttributeValidationError) {\n          errors.push({\n            expected: `${err.expected} element`,\n            index: i,\n            optional: err.optional,\n            got: err.got,\n          });\n        }\n        else {\n          throw err;\n        }\n      }\n    }\n    if (errors.length > 0) {\n      throw new AttributeValidationError(`valid ${this.name} fields`, errors, this.isOptional);\n    }\n\n    return input;\n  }\n\n  mergeDefault(value: mixed, nullIsUndefined: ?boolean): any {\n    if (value === undefined || (value === null && (!this.isOptional || nullIsUndefined))) {\n      return this.newDefault();\n    }\n    else if (value == null || !Array.isArray(value)) {\n      throw new Error('value must be an array (or undefined)');\n    }\n    else if (value.length !== this.elements.length) {\n      throw new Error('the number of elements must be equal');\n    }\n    else {\n      const arr = [];\n      for (let i = 0; i < this.elements.length; i++) {\n        arr.push(this.elements[i].mergeDefault(value[i], nullIsUndefined));\n      }\n      return arr;\n    }\n  }\n\n  newSkeleton(): ?Array<mixed> {\n    if (this.isOptional) {\n      return null;\n    }\n    else {\n      return this.elements.map(e => e.newSkeleton());\n    }\n  }\n\n  _clone(): TupleAttribute {\n    return new TupleAttribute(this.elements)._copyAttrProps(this);\n  }\n}\n\n/**\n Represents array and map attributes\n\n Optionally the values can be type-checked as well. Use `ofType` for this.\n\n If the attribute is marked as optional, `newSkeleton` will return null.\n Otherwise it creates an empty array or map.\n */\nexport class CompoundAttribute extends Attribute {\n  /** Attribute that all elements must have */\n  elementAttr: ?Attribute;\n\n  _skeletonMaker: () => mixed;\n  _iterator: ElementIterator;\n\n  constructor(validator: ValidatorFn, skeletonMaker: () => mixed, iterator: ElementIterator) {\n    super(validator, skeletonMaker);\n    this._skeletonMaker = skeletonMaker;\n    this._iterator = iterator;\n  }\n\n  /**\n   Bind a type to the contents of the compound attribute\n\n   All values of the compound will be validated against the given attribute.\n\n   Clones the attribute object.\n   */\n  ofType(spec: any): this {\n    const c = this._clone();\n    const elementAttr = toAttribute(spec);\n    c.elementAttr = elementAttr;\n    const i = this.name.indexOf('<');\n    if (i === -1) {\n      c.name = `${this.name}<${elementAttr.name}>`;\n    }\n    else {\n      c.name = `${this.name.substr(0, i)}<${elementAttr.name}>`;\n    }\n    return c;\n  }\n\n  validate(input: mixed): any {\n    super.validate(input);\n\n    if (input == null || this.elementAttr == null) {\n      return input;\n    }\n\n    const eltAttr = this.elementAttr;\n    const errors = [];\n    this._iterator(input, (elt, index) => {\n      try {\n        eltAttr.validate(elt);\n      }\n      catch (err) {\n        if (err instanceof AttributeValidationError) {\n          errors.push({\n            expected: `${err.expected} element`,\n            key: index,\n            optional: err.optional,\n            got: err.got,\n          });\n        }\n        else {\n          throw err;\n        }\n      }\n    });\n    if (errors.length > 0) {\n      throw new AttributeValidationError(`valid ${this.name} elements`, errors, this.isOptional);\n    }\n\n    return input;\n  }\n\n  newSkeleton() {\n    if (this.isOptional) {\n      return null;\n    }\n    else {\n      return this._skeletonMaker();\n    }\n  }\n\n  _clone(): CompoundAttribute {\n    return new CompoundAttribute(this._validator, this._skeletonMaker, this._iterator)._copyAttrProps(this);\n  }\n\n  _copyAttrProps(source: Attribute): this {\n    super._copyAttrProps(source);\n    // source is contravariant, need to check\n    if (source instanceof CompoundAttribute) {\n      this.elementAttr = source.elementAttr;\n    }\n    return this;\n  }\n}\n\n/**\n Represents a (plain) object attribute with fields of given types\n\n The default value is an object with default values of each type for each field.\n The skeleton is either `null` for optional schemas or an object with all values\n set to the skeleton of each type.\n */\nexport class SchemaAttribute extends Attribute {\n  /** Fields to validate */\n  fields: {[string]: Attribute};\n\n  constructor(sfields: {[string]: any}) {\n    if (typeofPlus(sfields) !== 'object') {\n      throw new Error('you need to pass a plain object describing the attributes');\n    }\n\n    const fields = {};\n    for (const f in sfields) {\n      if (hasOwnProperty(sfields, f)) {\n        fields[f] = toAttribute(sfields[f]);\n      }\n    }\n\n    super(x => typeofPlus(x) === 'object', () => {\n      const obj = {};\n      for (const f in fields) {\n        if (hasOwnProperty(fields, f)) {\n          obj[f] = fields[f].newDefault();\n        }\n      }\n      return obj;\n    });\n    this.fields = fields;\n  }\n\n  validate(input: any): any {\n    super.validate(input);\n\n    if (input == null) {\n      return input;\n    }\n\n    const errors = [];\n    for (const f in this.fields) {\n      if (hasOwnProperty(this.fields, f)) {\n        try {\n          this.fields[f].validate(input[f]);\n        }\n        catch (err) {\n          if (err instanceof AttributeValidationError) {\n            errors.push({\n              expected: `${err.expected} field`,\n              name: f,\n              optional: err.optional,\n              got: err.got,\n            });\n          }\n          else {\n            throw err;\n          }\n        }\n      }\n    }\n    if (errors.length > 0) {\n      throw new AttributeValidationError(`valid ${this.name}`, errors, this.isOptional);\n    }\n\n    return input;\n  }\n\n  mergeDefault(value: mixed, nullIsUndefined: ?boolean): any {\n    if (value === undefined || (value === null && (!this.isOptional || nullIsUndefined))) {\n      return this.newDefault();\n    }\n    else if (value == null || typeof value !== 'object') {\n      throw new Error('value must be an object (or undefined)');\n    }\n    else {\n      const obj = {};\n      for (const f in this.fields) {\n        if (hasOwnProperty(this.fields, f)) {\n          obj[f] = this.fields[f].mergeDefault(value[f], nullIsUndefined);\n        }\n      }\n      return obj;\n    }\n  }\n\n  newSkeleton() {\n    if (this.isOptional) {\n      return null;\n    }\n    else {\n      const obj = {};\n      for (const f in this.fields) {\n        if (hasOwnProperty(this.fields, f)) {\n          obj[f] = this.fields[f].newSkeleton();\n        }\n      }\n      return obj;\n    }\n  }\n\n  _clone(): SchemaAttribute {\n    return new SchemaAttribute(this.fields)._copyAttrProps(this);\n  }\n}\n\n/**\n Converts a fixed value or tuple or schema\n */\nexport function toAttribute(v: any): Attribute {\n  if (v instanceof Attribute) {\n    return v;\n  }\n\n  switch (typeofPlus(v)) {\n    case 'object': {\n      const a = new SchemaAttribute(v);\n      a.name = 'schema';\n      return a;\n    }\n    case 'array': {\n      const a = new TupleAttribute(v);\n      a.name = 'tuple';\n      return a;\n    }\n    default: {\n      const a = new FixedAttribute(v);\n      a.name = JSON.stringify(v);\n      return a;\n    }\n  }\n}\n\n/**\n Tests a value against a specification\n\n Returns true or false rather than trowing an exception\n */\nexport function isValid(spec: any, value: mixed): boolean {\n  try {\n    toAttribute(spec).validate(value);\n    return true;\n  }\n  catch (err) {\n    if (err instanceof AttributeValidationError) {\n      return false;\n    }\n    else {\n      throw err;\n    }\n  }\n}\n","//\n//  index.js\n//  validated-attributes\n//\n//  Created by Patrick Schneider on 17.05.17.\n//  Copyright (c) 2017 MeetNow! GmbH. All rights reserved.\n//\n// @flow\n//\n\nimport { AttributeValidationError, Attribute } from './base';\n\nimport { FixedAttribute, ObjectAttribute } from './simple';\n\nimport {\n  EnumAttribute,\n  TupleAttribute,\n  CompoundAttribute,\n  SchemaAttribute,\n  toAttribute,\n  isValid,\n} from './combined';\n\nimport type {\n  ValidatorFn,\n  DefaultValue,\n  ElementValidatorFn,\n  ElementIterator,\n} from './types';\n\nimport {\n  typeofPlus,\n  hasOwnProperty,\n  keys,\n} from './util';\n\nconst INTEGER_RE = /^[0-9]+$/;\nconst UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nconst STRING_DATE_RE = /^[0-9]{4}-(1[0-2]|0[1-9])-(3[01]|[1-2][0-9]|0[1-9])$/;\n\n// http://www.regular-expressions.info/email.html\nconst EMAIL_RE = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;\n\nconst required = {\n  fixed: (v: mixed) => {\n    const a = new FixedAttribute(v);\n    a.name = JSON.stringify(v);\n    return a;\n  },\n\n  string: new Attribute(x => typeofPlus(x) === 'string', ''),\n  integerString: new Attribute((x: any) => typeofPlus(x) === 'string' && INTEGER_RE.test(x), '0'),\n  nonemptyString: new Attribute((x: any) => typeofPlus(x) === 'string' && x.trim().length > 0, '-'),\n  uuid: new Attribute((x: any) => typeofPlus(x) === 'string' && UUID_RE.test(x), '00000000-0000-4000-8000-000000000000'),\n  email: new Attribute((x: any) => typeofPlus(x) === 'string' && EMAIL_RE.test(x), 'name@example.com'),\n  dateString: new Attribute((x: any) => typeofPlus(x) === 'string' && STRING_DATE_RE.test(x) && !Number.isNaN(Date.parse(x)), '2000-01-01'),\n\n  boolean: new Attribute(x => typeofPlus(x) === 'boolean', false),\n  number: new Attribute(x => typeofPlus(x) === 'number', 0),\n  integer: new Attribute(x => typeofPlus(x) === 'number' && x === parseInt(x, 10), 0),\n  regexp: new Attribute(x => typeofPlus(x) === 'regexp', () => new RegExp('')),\n  date: new Attribute(x => typeofPlus(x) === 'date', () => new Date()),\n  function: new Attribute(x => typeofPlus(x) === 'function', () => () => undefined),\n\n  array: new CompoundAttribute(\n    x => typeofPlus(x) === 'array',\n    () => [],\n    (a: Array<mixed>, ev: ElementValidatorFn) => a.forEach(ev)\n  ),\n  map: new CompoundAttribute(\n    x => typeofPlus(x) === 'object',\n    () => {},\n    (o: Object, ev: ElementValidatorFn) => keys(o).forEach(n => ev(o[n], n))\n  ),\n\n  tuple: (elements: Array<mixed>) => {\n    const a = new TupleAttribute(elements);\n    a.name = 'tuple';\n    return a;\n  },\n  schema: (fields: {[string]: mixed}) => {\n    const a = new SchemaAttribute(fields);\n    a.name = 'schema';\n    return a;\n  },\n\n  instanceOf: (cls: any) => {\n    const a = new ObjectAttribute(cls);\n    a.name = `instanceOf(${cls.name})`;\n    return a;\n  },\n  oneOf: (...args: Array<mixed>) => {\n    const a = new EnumAttribute(args);\n    a.name = `oneOf(${a.values.map((attr: Attribute) => attr.name).join(', ')})`;\n    return a;\n  },\n};\n\nfor (const attrName in required) {\n  if (hasOwnProperty(required, attrName)) {\n    const a = required[attrName];\n    if (typeof a !== 'function') {\n      a.name = attrName;\n    }\n  }\n}\n\nconst optional: typeof(required) = {\n  fixed: (v: mixed) => required.fixed(v).makeOptional(),\n\n  string: required.string.makeOptional(),\n  nonemptyString: required.nonemptyString.makeOptional(),\n  integerString: required.integerString.makeOptional(),\n  uuid: required.uuid.makeOptional(),\n  email: required.email.makeOptional(),\n  dateString: required.dateString.makeOptional(),\n\n  boolean: required.boolean.makeOptional(),\n  number: required.number.makeOptional(),\n  integer: required.integer.makeOptional(),\n  regexp: required.regexp.makeOptional(),\n  date: required.date.makeOptional(),\n  function: required.function.makeOptional(),\n\n  array: required.array.makeOptional(),\n  map: required.map.makeOptional(),\n\n  tuple: (elements: Array<mixed>) => required.tuple(elements).makeOptional(),\n  schema: (fields: {[string]: mixed}) => required.schema(fields).makeOptional(),\n  instanceOf: (cls: any) => required.instanceOf(cls).makeOptional(),\n  oneOf: (...args: Array<mixed>) => required.oneOf(...args).makeOptional(),\n};\n\nexport default {\n  typeofPlus,\n\n  Attribute,\n  FixedAttribute,\n  CompoundAttribute,\n  TupleAttribute,\n  SchemaAttribute,\n  ObjectAttribute,\n  EnumAttribute,\n  AttributeValidationError,\n\n  validate: (spec: any, value: mixed): any => toAttribute(spec).validate(value),\n  isValid,\n  newDefault: (spec: any): any => toAttribute(spec).newDefault(),\n  mergeDefault: (spec: any, value: mixed, nullIsUndefined: ?boolean): any => toAttribute(spec).mergeDefault(value, nullIsUndefined),\n  newSkeleton: (spec: any): any => toAttribute(spec).newSkeleton(),\n  toAttribute,\n\n  optional,\n  required,\n\n  ...required,\n};\n\nexport type {\n  ValidatorFn,\n  DefaultValue,\n  ElementValidatorFn,\n  ElementIterator,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;qBA6BmC;;;2BAID,MAAc;;;mBAOtB,QAAgB;;;;;;;;;;iBAcV;;;;;;;;;;;;sBAgBE,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EClDvC;;;;;;;;;;;;;;;;;;;;;;;gBAwDqB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECzDtB;;;;;;;;;;;;;;;;;;;;ECMA;;oBAEkB;;;;;;;;;;;;;;;;;;;;;iBAoCE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAgND;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WCnOV;;;;;;iCAOsB;;wBAET;;;;;;;;;;;;;;;;;;;kBAsBN;;;;;;;;;;kBAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}